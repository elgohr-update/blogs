---
* 目录
	* [什么是动态规划](#h1)
	* [找硬币问题](#h2)
	* [背包问题](#h3)
	* [裴波那契数列](#h4)
		1. [递归解法](#h4-1)
		2. [动态规划解法](#h4-2)

---

## 什么是动态规划 {#h1}

动态规划(Dynamic Programming)是一种求解决策过程最优化的数学方法，通过自底向上的求解子问题得到最终复杂问题的最优解。

听着概念可能云里雾里，还是来看看几个动态规划解题经典案例吧：

## 找硬币 {#h2}

给定一组硬币的面额，分别是1、4、5元。如果需要找8元的零钱，怎么做才能使硬币数量最少？

遇到这个问题，仔细一想可能会觉得硬币的面额不太符合常识啊(°∀°)ﾉ，一般不是1、2、5这样吗，为什么要设计出4这样奇怪的面额呢。其实找硬币这种问题在现实生活中都是通过贪心算法来找到答案的，1、2、5的面额找8元零钱，我们会先选择最大的5元硬币，剩下的钱再通过两枚第二大的2元硬币凑齐。

>[info] 据说面额组合n-1项的和不超过第n项的值，找硬币问题就可用贪心求解

再来看看1、4、5的组合找8元零钱用贪心算法，首先用面额最大的5元硬币凑，剩下的3元只能找3个1元的硬币，用到的硬币总数就是 3+1=4。可稍微~~穷举~~思考下找8元零钱明明只要用两枚4元硬币就可以凑齐。

对于贪心算法无法求解的极值问题我们就得好好考虑下动态规划了，对于该问题我们假设有一个函数`f(n) = 凑出n所需的最小硬币数量`，可以列一个表：

* f(1) = 1
* f(2) = ?
* f(3) = ?
* f(4) = 1
* f(5) = 1
* f(6) = ?

因为2、3只能用1元的硬币凑，f(2)可以表示为 f(2-1) + 1 就是 2，f(3)可以表示为 f(3-1) + 1 就是 3。

该函数的前5个值都很好求，但凑出6的最少硬币数呢？考虑三种情况

1. f(6) = f(6 - 1) + 1 = 2
2. f(6) = f(6 - 4) + 1 = 3
3. f(6) = f(6 - 5) + 1 = 2

分别表示找1、4、5的硬币后余下要找的钱需要的最少硬币数 + 1(这个1就是算这枚硬币本身)，可以发现最优解是2。

由此可以构建出一个公式:

```go
// 可以发现其对f(2),f(3)同样适用
f(n) = min{f(n-1), f(n-4), f(n-5)} + 1
```

也就是可以通过求f(1) f(2) ...这样的子问题解来构建出最终问题的解，此为动态规划的概念。

实现代码如下：

```go
package main

import (
	"math"
)

func main(){
	coin := []int{1, 4, 5}
	n := 8
	cost := make([]int, n + 1)
	// 全部初始化为最大值，方便用min()筛选出最小值
	for i := range cost {
		cost[i] = math.MaxInt32
	}
	cost[0] = 0
	// 初始化等于硬币面额的找零为1枚硬币
	// 通过这个初始条件就可以自底向上推出各情况下需要的最小硬币数量
	for _, num := range coin {
		cost[num] = 1
	}

	for i:=1; i<=n; i++ {
		for _, num := range coin {
			if num > i {
				continue
			}
			newCost := cost[i - num] + 1
			if newCost < cost[i] {
				cost[i] = newCost
			}
		}
	}
	println(cost[n])
}
```

## 背包问题 {#h3}

> 以下问题出自算法图解

假设你是个贪婪的小偷，背着可装n磅（1磅≈0.45千克）重东西的背包，在商场伺机盗窃各种可装入背包的商品。

![](https://kicoe-blog.oss-cn-shanghai.aliyuncs.com/IEyrpFJFETMjowiZMliQ.jpg)

你力图往背包中装入价值最高的商品，你会使用哪种算法呢？

算法图解中使用表格来记录各种情况下的最优价值，其中行是当前装入的商品，列是背包的容量

| | 1 | 2 | 3 | 4 |
| :------- | :----: | :----: | :----: | :----: |
| 1. 吉他 | 1500 | 1500 | 1500 | 1500 |
| 2. 音箱 | 1500 | 1500 | 1500  | 3000 |
| 3. 笔记本电脑 | 1500 | 1500 | 2000 | 3500 |

这个表格和找硬币中列表意义是一样的，从最小子问题的最优解构建出最终问题的解。求解其中的单元格也有一个公式：

```go
// i、j分别表示行列
cell[i][j] = max(cell[i][j-1], 当前商品价值 + cell[i-1][j-当前商品重量]
```

比如最后一个格子(3,4)价值计算方法为

```go
max(
	cell[2,4], // 上一个单元格的值 3000
	2000 + cell[2][1] // 也就是 当前商品价值 + 剩余空间价值 3500
)
```
所以(3,4)的值应该是3500。

##  斐波那契数列 {#h4}

[LeetCode - 40 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

我们再来设函数 `f(n) = 爬n阶楼顶的不同方法数`

爬到n阶的方法可以拆成：
1. 爬n-1阶楼梯的所有方法都可以派生出再爬一个1阶台阶到达n
2. 爬n-2阶楼梯的所有方法都可以派生出再爬一个2阶台阶到达n

* f(1) = 1
* f(2) = 2 *初始值稍有不同*
* f(3) = f(3-1) + f(3-2) = 3
* ...

这个状态转移方程就就更直观了(裴波那契数)：

```go
f(n) = f(n-1) + f(n-2)
```

### 递归写法 {#h4-1}

```go
func f(n int) int {
	if n < 1 {
		return 0
	}
	if n == 1 {
		return 1
	} else if n == 2 {
		return  2
	}

	return f(n-1) + f(n-2)
}
```

递归算是最清晰易懂的裴波那契数解法了，f(5)的执行过程展开如下

```
            f(5)
         /       \
      f(4)       f(3)
      /  \       / \
    f(3) f(2)  f(2) f(1)
    / \
f(2) f(1)
```

可以看到f(3) f(2)都重复执行了多次，树形递归时间复杂度O(n^2)。递归的执行是自顶向下，而动态规划偏向于从子问题一步步向上求解

### 动态规划写法 {#h4-2}

```go
func f(n int) int {
	if n == 1 {
		return 1
	}
	dp := make([]int, n+1)
	dp[1] = 1
	dp[2] = 2
	for i:=3; i<=n; i++ {
		dp[i] = dp[i-1] + dp[i-2]
	}
	return dp[n]
}
```
时间复杂度O(n)

当然最快的还是直接用裴波那契数列的通项公式：

![](https://kicoe-blog.oss-cn-shanghai.aliyuncs.com/ROrwGIIfHGXgGszhuSfI.jpg)

幂函数的时间复杂度为O(log(n))，空间复杂度为常量O(1)

## 参考

* [算法图解](https://www.ituring.com.cn/book/1864)
* [最优找零问题。贪心/动态规划](https://blog.csdn.net/jal517486222/article/details/83787279)
* [什么是动态规划（Dynamic Programming）？](https://www.zhihu.com/question/23995189/answer/613096905)